# Quick Sort
### 使用Divide and Conqure   
#### Quick Sort實現
1. 分割（Divide）

選擇數組中的一個元素作為「基準值」（pivot）
重新排列數組，使所有小於基準值的元素都在基準值的左側，所有大於基準值的元素都在基準值的右側
基準值現在處於其最終排序位置

2. 征服（Conquer）

遞歸地對基準值左側的子數組應用 Quick Sort
遞歸地對基準值右側的子數組應用 Quick Sort

3. 合併（Combine）

在 Quick Sort 中，不需要顯式的合併步驟，因為數組是就地（in-place）排序的
當所有遞歸調用完成後，整個數組已經排序完成

實例說明
假設我們有數組 [7, 2, 1, 6, 8, 5, 3, 4]，以最一般的方式（選擇最後一個元素作為基準值）實現 Quick Sort：

第一次分割：

選擇 4 作為基準值
分割後：[2, 1, 3] 4 [7, 6, 8, 5]
4 已在最終位置


對左側子數組 [2, 1, 3] 遞歸應用 Quick Sort：

選擇 3 作為基準值
分割後：[2, 1] 3 []
再對 [2, 1] 排序：[1] 2 []
左側子數組排序完成：[1, 2, 3]


對右側子數組 [7, 6, 8, 5] 遞歸應用 Quick Sort：

選擇 5 作為基準值
分割後：[] 5 [7, 6, 8]
再對 [7, 6, 8] 排序，最終得到 [5, 6, 7, 8]


結果組合：

整個數組排序完成：[1, 2, 3, 4, 5, 6, 7, 8]



分治法在 Quick Sort 中的特點

問題的分解：

原問題：排序整個數組
子問題：排序基準值左邊的子數組和右邊的子數組


遞歸終止條件：

當子數組的大小為 0 或 1 時（已經排序）


效率分析：

最佳情況：每次分割都將數組分成大致相等的兩部分，時間複雜度為 O(n log n)
最壞情況：每次都選擇最大或最小元素作為基準值，時間複雜度退化為 O(n²)
平均情況：O(n log n)



分治法使 Quick Sort 成為一個高效的排序算法，特別是在實際應用中，它通常比其他 O(n log n) 的排序算法（如合併排序）表現更好，因為它有較小的常數因子和良好的局部性。